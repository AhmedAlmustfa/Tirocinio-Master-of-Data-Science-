---
title: "Shiny Moduls"
format: HTML
---

# Shiny modules for repeated structurees

## Why Modules?
The simplest way to define a modules that, modules can be thought of as "function-ization" of a set of Shiny UI and server elements. The magic of modules comes because these functions are constructed in a special way that creates a *namespace*. So far, when writing an app, the names (ids) of the controls are global: all parts of your server function can see all parts of your UI. Modules give you the ability to create controls that can only be seen from within the module. This is called a namespace because it creates “spaces” of “names” that are isolated from the rest of the app.

Shiny modules have two big advantages:
* Namespacing makes it easier to understand how your app works because you can write, analyse, and test individual components in isolation.
* because modules are functions they help you reuse code; anything you can do with a function, you can do with a module. For more depth in the argument visit: https://mastering-shiny.org/scaling-modules.html

## Motivation
The example that I am going to illustrate has nearly identical UI or server function, that hve been used over and over in the same app, and here comes the benefit of using modules to avoid repeating the codes. The app in this example simply makes scatterplot and table for different dataset. Beloow is a preview of the final application.

![The preview of the final app](Screenshot (47).png)

## Set-up the required libraries
1- load **library(shiny)**
2- load **library(ggplot2)**

## Modularizing the UI
The three tabPanels below have identically the same patterns. 
```{r}
library(shiny)
library(ggplot2)
```


```{r}
    tabPanel("Penguins",{
      sidebarLayout(
        sidebarPanel(
          selectInput(
            "select_var1_penguins",
            "variable 1",
            choices = names(palmerpenguins::penguins)
          ),
          selectInput(
            "select_var2_penguins",
            "variable 2",
            choices = names(palmerpenguins::penguins)
          ),
          actionButton(
            "draw_scatterplot_penguins",
            "Draw scatterplot"
          )
        ),
        mainPanel(
          plotOutput("scatterplot_penguins")
        )
      )
    })

    tabPanel("Iris",{
      sidebarLayout(
        sidebarPanel(
          selectInput(
            "select_var_1_iris",
            "Variable 1",
            choices = names(iris)
          ),
          selectInput(
            "select_var_2_iris",
            "Variable 2",
            choices = names(iris)
          ),
          actionButton(
            "draw_scatterplot_iris",
            "Draw scatterplot"
          )
        ),
        mainPanel(
          plotOutput("scatterplot_iris")
        )
      )
    })
    tabPanel("mtcars",{
      sidebarLayout(
        sidebarPanel(
          selectInput(
            "select_var_1_mtcars",
            "Variable 1",
            choices = names(mtcars)
          ),
          selectInput(
            "select_var_2_mtcars",
            "Variable 2",
            choices = names(mtcars)
          ),
          actionButton(
            "draw_scatterplot_mtcars",
            "Draw scatterplot"
          )
        ),
        mainPanel(
          plotOutput("scatterplot_mtcars")
        )
      )
    })
```

The first thing to do to modularizing this code is to make a function that creates the UIs that taked id as first argument and then any other changing aspects. The changes in this example is that the choices are different for each selectInput(), so we'll make a function that has the arguments id and choices.

The first line of a UI module function is always ns <- NS(id), which creates a shorthand way to add the base id to the id type. So instead of the selectInput()'s name being "palmerpenguins::penguins", "iris",  or "mtcars", I set it as ns("The variable selected"). All ids need to use ns() to add the namespace to their ID.

```{r}
plot_UI <- function(id, dataset) {
  ns <- NS(id)
  tagList(
    sidebarLayout(
      sidebarPanel(
        selectInput(
          ns("select_var1"),
          "variable 1",
          choices = names(dataset)
        ),
        selectInput(
          ns("select_var2"),
          "variable 2",
          choices = names(dataset)
        ),
        actionButton(
          ns("draw_scatterplot"),
          "Draw scatterplot"
        )
      ),
      mainPanel(
        plotOutput(ns("scatterplot")),
        DT::dataTableOutput(ns("table"))
      )
    )
  )
}
```


:::{.callout-note}
Now the tabPanel can be replaced with jist the following code.
:::

```{r}
    tabPanel("Penguins", plot_UI("Penguin", palmerpenguins::penguins))
    tabPanel("Iris",plot_UI("Iris", iris))
    tabPanel("mtcars",plot_UI("mtcars", mtcars))
```

## Modularizing server functions
In the the script below we have three functions that creats the output plots for each dataset, but this code is largely redundent, 


```{r}
server <- function(input, output, session){
  output$scatterplot_penguins <- renderPlot({
    ggplot(palmerpenguins::penguins) + 
      geom_point(
        aes_string(input$select_var1_penguins, input$select_var2_penguins),
        size = 3,
        alpha = 0.5,
        col = "dodgerblue4"
      )
  }) |> bindEvent(input$draw_scatterplot_penguins)
  
  output$scatterplot_iris <- renderPlot({
    ggplot(iris) +
      geom_point(
        aes_string(input$select_var_1_iris, input$select_var_2_iris),
        size = 3,
        alhpa = 0.5,
        col = "dodgerblue4"
      )
  })|> bindEvent(input$draw_scatterplot_iris)
  
  output$scatterplot_mtcars <- renderPlot({
    ggplot(mtcars) +
      geom_point(
        aes_string(input$select_var_1_mtcars, input$select_var_2_mtcars),
        size = 3,
        alhpa = 0.5,
        col = "dodgerblue4"
      )
  })|> bindEvent(input$draw_scatterplot_mtcars)
}

```

The second step to modularizing code is creating a server function, where you can write the functions that relate to the input and output in UI function, so in this illustration I include two functions, one to produce the output plot and the other for producing the output table.

The first argoment in the server function is id, and then in the example here the argument that take different data "dataset" that will be used in different plots and tables.

A server function always contains moduleServer() set up like below.

```{r}
tabPanelServer <- function(id, data, group_by) {
    moduleServer(id, function(input, output, session) {
      # code ...
    })
}
```

Now we can copy and paste our code where

```{r}
plot_server <- function(id, dataset) {
  moduleServer(
    id,
    function(input, output, session){
      output$scatterplot <- renderPlot({
        ggplot(dataset) + 
          geom_point(
            aes_string(input$select_var1, input$select_var2),
            size = 4,
            alpha = 0.5,
            col = "dodgerblue4"
          ) + 
          theme_minimal()
      }) |> bindEvent(input$draw_scatterplot)
      
      output$table <- DT::renderDataTable({
        dataset
      })
    }
  )
}
```

:::{.callout-note}
Now, you can replace the four functions inside the server function with these two lines of code.
:::

```{r}
  plot_server("Penguin", palmerpenguins::penguins) 
  plot_server("Iris" , iris)
  plot_server("mtcars", mtcars)
```

## Conclusion
In this examlpe we reduce a numbers of lines of code through modulraizing sine its a simple project, but modularization can save a lot of times and effeorts, for instance in this example if we want to change the plot layout "geom" we just need to change it in one function. and this is one of the power of using modularization specially in big projects.